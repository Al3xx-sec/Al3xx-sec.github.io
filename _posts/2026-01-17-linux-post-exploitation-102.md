---
title: "Linux Post-Exploitation 102: Breaking Out and Moving Up"
date: 2026-01-17 00:00:00 +0800
categories: [Methodology]
tags: [linux, privilege escalation, post-exploitation, enumeration]
image: /assets/img/got-root.png
---

In the previous post, we focused on the passive side of post-exploitation: understanding where we landed, who we are, and what secrets the system might already be leaking.

But sometimes enumeration isn't enough.

Sometimes you get a shell that feels more like a prison. Or you notice a cron job running as root, but you can't edit the script itself. Or everything looks locked downâ€¦ yet something still feels off.

This is where active environment manipulation begins.

Instead of just observing the system, we start tricking it into doing our work for us.

## 1. The Prison Break: Escaping Restricted Shells

Occasionally, you'll land a shell only to realize it's heavily restricted.

You can't `cd`.  
You can't set environment variables.  
Half your usual commands return "not found."

Chances are, you're inside a restricted shell like `rbash` or `rksh`.

Don't panic. In most cases, these shells are security theater, a thin veil that falls apart under light pressure.

### Look for Escape Hatches

If you can run anything interactive, you may already be free.

Editors and pagers are classic offenders:

- `vi`
- `vim`
- `less`
- `man`

If `vi` is available, it's usually game over:

```vim
:!/bin/sh
```

You're no longer in a restricted shell, you're in a real one.

### Abuse Installed Programming Languages

Restricted shells often limit commands, not interpreters.

If the system has Python, Perl, or Ruby installed, they usually ignore shell restrictions entirely.

```bash
python3 -c 'import os; os.system("/bin/bash")'
```

At that point, the restriction is effectively bypassed.

### Try Command Chaining

Some restrictions only apply to the first command.

Test separators like:

- `;`
- `|`
- `&&`

You'd be surprised how often the second command executes with fewer limitations.

## 2. PATH Abuse: The "Fake Binary" Attack

This is one of my favorite techniques because of how clean it is.

Linux decides which command to run using the `$PATH` variable, a list of directories it searches in order.

If I type:

```bash
ls
```

The system walks the PATH until it finds an executable named `ls`.

That behavior is exploitable.

### The Dangerous Scenario

If:

1. The current directory (`.`) is in `$PATH`, or
2. You can modify `$PATH`

Then you can hijack command execution.

Imagine a script or cron job runs a command like:

```bash
ls
```

If your directory is checked before `/bin`, your version of `ls` wins.

### The Attack

```bash
# Add current directory to the front of PATH
export PATH=.:$PATH

# Create a fake "ls" binary
echo "/bin/bash" > ls
chmod +x ls
```

Now wait.

When a user or script runs `ls` from that directory, they're not listing files.

They're handing you their privileges. This technique is simple, silent, and devastating.

## 3. Wildcard Abuse: When Filenames Become Flags

This one feels like a magic trick the first time you see it. Linux expands wildcards (`*`) before running a command. That means filenames can secretly turn into command-line arguments.

If a privileged process blindly uses wildcards, you can weaponize them.

### The Classic Tar Trap

Imagine a root cron job running something like:

```bash
tar cf backup.tar.gz *
```

And you can write to that directory. That's all you need.

### The Exploit

Instead of real files, we create filenames that look like flags.

```bash
# Script we want executed as root
echo 'echo "student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh

# Malicious filenames
touch "--checkpoint=1"
touch "--checkpoint-action=exec=sh root.sh"
```

When `tar *` runs, the shell expands `*` into:

```
--checkpoint=1
--checkpoint-action=exec=sh root.sh
```

Tar doesn't see filenames. It sees instructions.

And just like that, you've modified `/etc/sudoers` without ever having root.

## Summary: Think Like the Shell

Every technique in this post shares the same idea:

- If `$PATH` says "look here first," Linux will obey.
- If a wildcard expands into flags, the program will process them.
- If a restricted shell lets you open an editor, it's no longer restricted.

Linux doesn't second-guess instructions. It does exactly what it's told, even when that's a mistake.

![got-root](/assets/img/got-root.png)

## What's Next?

In Part 3, we'll stop manipulating the environment and start abusing the system's core security model. We'll dive into file permissions, SUID binaries, and Linux capabilities.
